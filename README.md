# Code-Optimization
Code optimization is a crucial step in the compiler design process that aims to improve the efficiency and performance of the generated code. The optimization process involves analysing the code to identify and eliminate inefficiencies, such as redundant calculations, unnecessary memory operations, and excessive control flow.
The ultimate goal of code optimization is to reduce the execution time and memory usage of the code while preserving the functionality and correctness. 

The code optimizer maintains a key-value mapping that resembles the symbol table structure to keep track of variables and their values (possibly after expression evaluation). This structure is used to perform constant folding followed by dead code elimination.
It takes input.txt file as input which contains the three address code in quadruple form, performs Constant Folding and Dead Code optimization and provides the optimized code as output in output.txt.

- Constant Follding - It is a technique used in computer programming and compiler optimization to improve the performance of code by evaluating constant expressions at compile time instead of at runtime. In constant folding, expressions containing constant operands are evaluated at compile time and the result is substituted for the expression in the code. This reduces the computational overhead at runtime and can also simplify the code.
- Dead Code Elimination - It is a technique used in computer programming to remove portions of code that are not needed or do not have any effect on the output of the program. Dead code refers to the code that is never executed during the runtime of the program or is executed but has no effect on the output of the program. This code can be the result of unused variables, unreachable code, or redundant code. Dead code elimination can be an essential optimization technique in software development because it can reduce the size of the program, improve its performance, and make it easier to maintain. By removing the 
dead code, the compiler can produce more efficient code, which can result in faster program execution and smaller executable files.

# Methdology and Techniques
1. The given code is a Python program that takes input text from the user, writes it to a file named "input.txt", reads the file, performs constant folding optimization on the code present in the file and prints the intermediate output of the optimization, and then performs dead code elimination and prints the final optimized code.
2. The program first prompts the user to enter the text and then uses a while loop to read each line of the input until it encounters an EOFError. The input lines are then appended to a list named "text_input" and joined together using the "\n" separator to form a single string "text_input_str".
3. The program then opens a file named "input.txt" in write mode and writes the text input to the file. It then reopens the same file in read mode and reads the lines of the file into a list named "list_of_lines".
4. The program initializes a dictionary named "dictValues" to store the values of variables in the code, three lists named "constantFoldedList", "constantFoldedExpression", and "dead Code Elimination" to store intermediate results, and an empty string "output_string" to store the final optimized code.
5. The program then performs constant folding optimization on the code present in the "list_of_lines" list. It iterates over each line of the list and checks if the operation is one of the arithmetic operators ("+", "-", "*", "/"). If it is, it checks if both the arguments are constants, if yes, it evaluates the expression and stores the result in the "dictValues" dictionary and appends the optimized instruction in "constantFoldedList". If one or both of the arguments are variables, it checks if the values of the variables are present in the "dictValues" dictionary. If both the values are present, it evaluates the expression, stores the result in the "dictValues" dictionary and appends the optimized instruction in
"constantFoldedList". If only one value is present, it replaces the value in the instruction with the value from the "dictValues" dictionary and appends the instruction to the "constantFoldedList". If none of the values are present, it appends the instruction to the "constantFoldedList" as is.
6. If the operation is an assignment ("="), it checks if the right-hand side value is a constant, if yes, it stores the constant value in the "dictValues" dictionary and appends the optimized instruction in "constantFoldedList". If it is a variable, it checks if the value of the variable is present in the "dictValues" dictionary. If yes, it replaces the value in the instruction with the value from the "dictValues" dictionary and appends the optimized instruction to the "constantFoldedList". If the value is not present, it appends the instruction to the "constantFoldedList" as it is.
7. If the operation is not an arithmetic operator or an assignment, it appends the instruction to the "constantFoldedList" as is.
8. The program then prints the optimized instructions present in "constantFoldedList" and stores them in the "constantFoldedExpression" list.
9. The program then performs dead code elimination on the instructions present in "constantFoldedList". It iterates over each instruction of "constantFoldedList" and checks if it is an assignment instruction. If yes, it skips the instruction. If it is an arithmetic operation, it appends the instruction to the "dead dElamination" list. If it is a control flow instruction ("if", "goto", "label", "not"), it appends the instruction to the
"dead Code Elimination" list.
10. Finally, the program prints the instructions present in the "deadCode Elimination" list, which represents the optimized code after dead code.

